1. 定时任务调度完后，才开始执行重试任务
   1.1 获取 redis 中记录的所有失败api，此为一组任务，然后遍历所有失败api。注意这里的请求仍然受 ifast 的最大请求制约；
   1.2 重试请求 api 仍然可能会失败，则在一组任务完成后，再次重复 1.1，直到没有失败 api 为止，或者接收到停止信号；
2. 下一次定时到达时，则发送停止重试信号，避免两边同时进行请求，造成不必要的请求。


定时任务针对的是 module，当定时到达时发送相应的信号。
初始化时，请求所有，完成后，启用定时。当任一定时触发时，都会执行 compose，在compose 内部判断各 api 是否需要执行，但是从库中获取数据。
考虑短时间内多次重启的情况：如果最近的调度的时间，小于一个定时周期，则不初始化。

注意，这里调度必须以 api 中最频繁的那个为准，也就是间隔一小时的。



考虑 apikey 获取的问题：apikey 只存放在 redis 中，如果拿不到，就等待获取


考虑扩展性和灵活性：例如，产品可能会要求增加/变更请求另一个或多个接口（如：净值调整），那么此时就可能发生 compose 组合变化。

如果在循环执行的过程中，定时到了触发，则重新循环，然后每个 api 执行前还要判断它最近一次执行的时间，如果小于一个定时周期就跳过执行


未实现：
1. 重试的逻辑：简单，另起一个携程，Timer 每隔 1 分钟检查一次，如果有失败的 api，则重试，直到没有失败的 api 为止。
2. 历史禁止循环请求，以及计算涨跌幅的逻辑：中级难度。
3. 重试要有一个判断逻辑，当定时任务在执行时，不能重试。所以重试的携程需要在定时循环之后启动。
